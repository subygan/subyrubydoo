import logging
import random

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Updater, MessageHandler, Filters, CallbackContext, CallbackQueryHandler
import json
import hashlib
import os
import sqlite3
import asyncio
import requests
import json
from icecream import ic

DB_NAME = 'db/subyrubydoo.sqlite3'

CHECK_CHAR = 'âœ…'
UNCHECK_CHAR = 'â¬œ'


def gen_db():
    # table: Replies
    # message_and_chat_id, reply_id, created_at
    # unique index on message_id
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            CREATE TABLE IF NOT EXISTS Replies (
                message_and_chat_id VARCHAR(255) NOT NULL,
                reply_and_chat_id VARCHAR(255) NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                state TEXT,
                PRIMARY KEY (message_and_chat_id),
                UNIQUE (reply_and_chat_id)
            )
        ''')

        # Crea

        db.execute('''
                    CREATE TABLE IF NOT EXISTS User (
                        tg_user_id VARCHAR(255) NOT NULL,
                        habitica_user_id VARCHAR(255) NOT NULL,
                        habitica_api_key VARCHAR(255) NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        state TEXT,
                        PRIMARY KEY (tg_user_id)
                    )
                ''')

        db.commit()


def cleanup_old_replies():
    # delete posts older then 1 year
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            DELETE FROM Replies WHERE created_at < datetime('now', '-1 year')
        ''')

        db.commit()


def get_reply_by_message_id(message_id, chat_id) -> tuple:
    ic(message_id, chat_id)
    with sqlite3.connect(DB_NAME) as db:
        cursor = db.execute('''
            SELECT reply_and_chat_id, state FROM Replies WHERE message_and_chat_id = ?
        ''', (f"{chat_id}_{message_id}",))

        row = cursor.fetchone()
        if not row:
            return None, None
        return row[0], json.loads(row[1]) if row[1] else {}


def get_reply_by_reply_id(reply_id, chat_id) -> tuple:
    ic(reply_id, chat_id)
    with sqlite3.connect(DB_NAME) as db:
        cursor = db.execute('''
            SELECT reply_and_chat_id, state FROM Replies WHERE reply_and_chat_id = ?
        ''', (f"{chat_id}_{reply_id}",))

        row = cursor.fetchone()
        if not row:
            return None, None
        return row[0], json.loads(row[1]) if row[1] else {}


def insert_reply(message_id, reply_id, chat_id, state: dict):
    with sqlite3.connect(DB_NAME) as db:
        db.execute(
            '''
            INSERT INTO Replies (message_and_chat_id, reply_and_chat_id, state) VALUES (?, ?, ?)
            ''',
            (f"{chat_id}_{message_id}", f"{chat_id}_{reply_id}", json.dumps(state))
        )

        db.commit()


def update_reply(reply_id, chat_id, state: dict):
    ic(reply_id, chat_id, state)
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            UPDATE Replies SET state = ? WHERE reply_and_chat_id = ?
        ''',
                   (json.dumps(state), f"{chat_id}_{reply_id}"))

        db.commit()


logger = logging.getLogger(__name__)

TOKEN = os.environ.get('TG_TOKEN', "")

if not TOKEN:
    print('TG_TOKEN not specified in env, please set TG_TOKEN with your bot token generated by @BotFather')
    exit(1)


def button_click(update, context):
    query = update.callback_query

    if query.data.startswith('toggle__'):
        index = query.data.replace('toggle__', '')

        if not query.message.reply_markup:
            print(f'no reply_markup for message_id {query.message.message_id} and chat_id {query.message.chat_id}')
            return

        for i, btn in enumerate(query.message.reply_markup.inline_keyboard):
            checked = btn[0].text.startswith(CHECK_CHAR)
            btn_text = btn[0].text.replace(f'{UNCHECK_CHAR} ', '').replace(f'{CHECK_CHAR} ', '')
            if i == int(index):
                print('found a btn', btn_text)
                new_text = f'{CHECK_CHAR} {btn_text}' if not checked else f'{UNCHECK_CHAR} {btn_text}'
                btn[0].text = new_text
                prev_state = get_reply_by_reply_id(query.message.message_id, query.message.chat_id)[1]
                try:
                    if not checked:
                        ic(update, context)
                        # reply_and_chat_id, state = get_reply_by_reply_id(query.message.message_id,
                        #                                                  query.message.chat_id)
                        task_id = prev_state.get(btn_text).get('habitica_task_id', None)
                        complete_habitica_task(query.from_user.id, task_id)
                        prev_state[btn_text] = {
                            "state": True,
                            "habitica_task_id": task_id
                        }
                    else:
                        habitica_task_id = create_habitica_task(query.from_user.id, btn_text)
                        prev_state[btn_text] = {
                            "state": False,
                            "habitica_task_id": habitica_task_id
                        }
                except Exception as e:
                    ic("button click exception", e)
                update_reply(query.message.message_id, query.message.chat_id, prev_state)
                break

        # prev_state = get_reply_by_message_id(query.message.message_id, query.message.chat_id)[1]
        # state = {}
        # for btn in query.message.reply_markup.inline_keyboard:
        #     checked = btn[0].text.startswith(CHECK_CHAR)
        #     btn_text = btn[0].text.replace(f'{UNCHECK_CHAR} ', '').replace(f'{CHECK_CHAR} ', '')
        #     state[btn_text] = checked

        # reply_id = query.message.message_id
        # update_reply(reply_id, query.message.chat_id, state)

        context.bot.edit_message_text(
            chat_id=query.message.chat_id,
            message_id=query.message.message_id,
            text=f'Click to toggle',
            reply_markup=query.message.reply_markup
        )


def md5hash(text):
    return hashlib.md5(text.encode('utf-8')).hexdigest()


def echo(update: Update, context: CallbackContext) -> None:
    """
    This function would be added to the dispatcher as a handler for messages coming from the Bot API
    """
    print("echo")

    msg = None
    update_object = None

    if update.channel_post:
        print('channel post')
        print(update.channel_post)
        msg = update.channel_post.text
        update_object = update.channel_post
    elif update.message and not update.message.reply_to_message:
        print('message')
        print(update)
        print(update.message)
        msg = update.message.text
        update_object = update.message
    elif update.edited_message:
        print('edited message')
        print(update.edited_message)
        msg = update.edited_message.text
        update_object = update.edited_message

    elif update.edited_channel_post:
        print('edited channel post')
        print(update.edited_channel_post)
        msg = update.edited_channel_post.text
        update_object = update.edited_channel_post
    if not msg:
        print('Unrecognized update')
        print(update)
        return

    is_update = update.edited_message or update.edited_channel_post
    previous_state = {}
    # reply_id_with_message_id = None
    if is_update:
        message_id = update_object.message_id
        ic(message_id, update_object.chat_id)
        reply_id_with_message_id, previous_state = get_reply_by_message_id(message_id, update_object.chat_id)
        ic(reply_id_with_message_id, previous_state)
        if not reply_id_with_message_id:
            print(f'reply_id for message_id {message_id} and chat_id {update_object.chat_id} not found')
            return

    ic(is_update)
    lines = msg.split('\n')
    ic(lines)
    keyboard = []

    index = 0
    new_state = {}
    for line in lines:
        line_strip = line.strip()
        if line_strip == '':
            continue
        keyboard.append([InlineKeyboardButton(
            f"{CHECK_CHAR if previous_state.get(line_strip, {}).get('state', False) else UNCHECK_CHAR} {line_strip}",
            callback_data=f"toggle__{index}"
        )])
        index += 1
        task_bool_state = False
        try:
            if not (line_strip in previous_state):
                habitica_task_id = create_habitica_task(update.message.from_user.id, line_strip)
            else:
                habitica_task_id = previous_state[line_strip].get('habitica_task_id', None)
                task_bool_state = previous_state[line_strip].get('state', False)
        except Exception as e:
            print(e)

        new_state[line_strip] = {
            "state": task_bool_state,
            "habitica_task_id": habitica_task_id
        }

    if is_update:
        update_reply(reply_id_with_message_id.split('_')[1], update_object.chat_id, new_state)

    reply_markup = InlineKeyboardMarkup(keyboard)

    if is_update:

        # find previous reply to same message and edit it
        # this is a workaround for editing messages in channels
        #
        ic(reply_id_with_message_id)
        reply_id = reply_id_with_message_id.split('_')[1]
        context.bot.edit_message_reply_markup(
            chat_id=update_object.chat_id,
            message_id=reply_id,
            reply_markup=reply_markup
        )

    else:
        # add new reply
        reply = update_object.reply_text('Click to toggle', reply_markup=reply_markup)
        reply_id = reply.message_id
        message_id = update_object.message_id
        chat_id = update_object.chat_id
        insert_reply(message_id, reply_id, chat_id, new_state)


## Habitica APIs go here

def create_new_habitica_user(update: Update, context: CallbackContext):
    print("----------------")
    print(update)

    update_object = update.message
    txt = update_object.text
    txt_split = txt.split(' ')
    if len(txt_split) == 1:
        update_object.reply_text('''Hey!! ðŸ¤“ 
        to add habitica integration send a message with the following format:

/habitica <habitica_user_id> <habitica_api_key>''')
    elif len(txt_split) == 3:
        habitica_user_id = txt_split[1]
        habitica_api_key = txt_split[2]
        tg_user_id = update_object.from_user.id
        with sqlite3.connect(DB_NAME) as db:
            db.execute(
                f'''
                INSERT INTO User (tg_user_id, habitica_user_id, habitica_api_key) VALUES (?, ?,?) ON CONFLICT(tg_user_id) DO UPDATE SET
    habitica_user_id = ?,
    habitica_api_key = ?;
                ''',
                (tg_user_id, habitica_user_id, habitica_api_key, habitica_user_id, habitica_api_key)
            )
            update_object.reply_text('Habitica integration added successfully ðŸ¤—.')
            db.commit()
    else:
        update_object.reply_text('ðŸ˜± Invalid format. Please use, /habitica <habitica_user_id> <habitica_api_key>')


def get_habitica_user(tg_user_id):
    with sqlite3.connect(DB_NAME) as db:
        cursor = db.execute('''
            SELECT habitica_user_id, habitica_api_key FROM User WHERE tg_user_id = ?
        ''', (tg_user_id,))

        row = cursor.fetchone()
        if not row:
            return None, None
        return row[0], row[1]


def create_habitica_task(user_id, text):
    ic(text)

    user_id, api_key = get_habitica_user(user_id)

    url = "https://habitica.com/api/v3/tasks/user"

    payload = json.dumps({
        "text": text,
        "type": "todo",
        # "alias": "hab-api-tasks",
        # "notes": "Update the tasks api on GitHub",
        # "checklist": [
        #     {
        #         "text": "read wiki",
        #         "completed": True
        #     },
        #     {
        #         "text": "write code"
        #     }
        # ],
        "priority": random.choice([0.1, 1, 1.5, 2.0])
    })
    headers = {
        'x-api-user': user_id,
        'x-api-key': api_key,
        'x-client': '',
        'Content-Type': 'application/json',
    }

    response = requests.request("POST", url, headers=headers, data=payload)

    # ic(response.json())
    ic(response.json()["data"]["_id"])
    return response.json()["data"]["_id"]


def complete_habitica_task(user_id, task_id):
    url = f'https://habitica.com/api/v3/tasks/{task_id}/score/up'

    user_id, api_key = get_habitica_user(user_id)
    payload = {}
    headers = {
        'x-api-key': api_key,
        'x-api-user': user_id,
    }

    response = requests.request("POST", url, headers=headers, data=payload)

    print(response.text)


def main() -> None:
    gen_db()
    cleanup_old_replies()
    updater = Updater(TOKEN)

    # Get the dispatcher to register handlers
    # Then, we register each handler and the conditions the update must meet to trigger it
    dispatcher = updater.dispatcher

    dispatcher.add_handler(CallbackQueryHandler(button_click))

    # Echo any message that is not a command
    dispatcher.add_handler(MessageHandler(~Filters.command, echo))
    dispatcher.add_handler(MessageHandler(Filters.command, create_new_habitica_user))

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C
    updater.idle()


if __name__ == '__main__':
    print("startin server")
    main()
